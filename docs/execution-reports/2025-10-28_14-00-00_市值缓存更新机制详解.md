# 市值缓存更新机制详解

## 任务时间
2025-10-28 14-00:00

## 概述

市值缓存采用**双层缓存架构** + **多触发更新机制**，确保数据及时性、性能和可靠性的平衡。

## 🏗️ 双层缓存架构

### L1 缓存 - Redis (1小时TTL)
```
作用: 快速读取 (~1-2ms)
策略: SETEX key 3600 value
位置: 内存缓存，进程内访问
适用: 高频访问的热门股票
```

### L2 缓存 - MongoDB (24小时有效期)
```
作用: 持久化存储
策略: validUntil字段控制
位置: 数据库持久化存储
适用: 所有股票的长期存储
```

## 🔄 更新触发机制

### 1️⃣ 定时任务更新 (主要机制)

**配置**: Inngest定时任务
```typescript
// 文件: lib/inngest/functions.ts:133-181
{
  event: 'app/update.market.cap',
  cron: '30 21 * * 1-5'  // 周一到周五 UTC 21:30
}
```

**执行流程**:
```
┌─────────────────────────────────────────┐
│  定时触发 (UTC 21:30, 美股收盘后)          │
└──────────────┬──────────────────────────┘
               ↓
┌─────────────────────────────────────────┐
│  Step #1: 获取所有观察列表股票             │
│  getAllWatchlistSymbols()               │
│  ├─ 查询MongoDB: Watchlist             │
│  ├─ 去重所有用户的所有股票               │
│  └─ 返回: symbol[]                      │
└──────────────┬──────────────────────────┘
               ↓
┌─────────────────────────────────────────┐
│  Step #2: 批量分片处理 (100支/批)         │
│  for (batch of 100 symbols) {           │
│    getMarketCapCache(batch)             │
│  }                                       │
└──────────────┬──────────────────────────┘
               ↓
┌─────────────────────────────────────────┐
│  Step #3: 写入双层缓存                   │
│  ├─ Redis L1: TTL=1小时                │
│  └─ MongoDB L2: validUntil=24小时        │
└──────────────┬──────────────────────────┘
               ↓
┌─────────────────────────────────────────┐
│  返回统计                               │
│  { successCount, errorCount }           │
└─────────────────────────────────────────┘
```

**优势**:
- ✅ 每日美股收盘后统一更新
- ✅ 批量处理，API利用率高
- ✅ 分批执行，单个失败不影响整体
- ✅ 统计报告，便于监控

### 2️⃣ 预缓存机制 (即时触发)

**触发时机**: 添加股票到观察列表时
```typescript
// 文件: lib/actions/watchlist.actions.ts:84-91
// 4️⃣ 异步预缓存市值数据（不阻塞响应）
getMarketCapCache([normalizedSymbol])
    .then(() => {
        console.log(`[Watchlist] ✅ Pre-cached market cap for ${normalizedSymbol}`);
    })
    .catch((err) => {
        console.warn(`[Watchlist] ⚠️ Pre-cache failed for ${normalizedSymbol}:`, err);
    });
```

**执行流程**:
```
用户添加股票 → 创建Watchlist记录 → 异步调用getMarketCapCache → 返回响应
                                                      ↓
                                              缓存命中：直接返回
                                              缓存缺失：获取并写入
```

**优势**:
- ✅ 用户刚添加的股票立即可用
- ✅ 异步执行，不阻塞UI响应
- ✅ 失败容忍，不影响主流程

### 3️⃣ 被动更新机制 (按需触发)

**触发时机**: 读取缓存时发现过期
```typescript
// 文件: lib/actions/heatmap.actions.ts:124-136
const missingSymbols = normalizedSymbols.filter(s => !resultMap.has(s));

if (missingSymbols.length === 0) {
    // 缓存全命中，直接返回
    return resultMap;
}

// 缓存有缺失，获取缺失的数据
const yahooQuotes = await fetchInBatches(missingSymbols, 50, getBatchQuotesFromYahoo);
```

**执行流程**:
```
读取缓存 → 检查过期 → 过期则获取 → 写入新数据 → 返回
```

**优势**:
- ✅ 自动补全缺失数据
- ✅ 用户无感知
- ✅ 保证数据可用性

## 📅 缓存生命周期

### MongoDB L2 (长期存储)
```
写入时间: T日 21:30
有效期: T日 00:00 - T+1日 00:00 (24小时)
过期检查: 查询时自动过滤 (validUntil > now)
清理策略: 无自动清理，保留历史数据
```

### Redis L1 (快速缓存)
```
写入时间: 首次访问后
有效期: 1小时 (3600秒)
过期策略: Redis自动清理 (TTL)
刷新机制: L2命中时自动刷新L1
```

## 🔍 过期检查逻辑

### MongoDB 查询条件
```typescript
// 文件: lib/cache/market-cap-cache-manager.ts:144-147
const now = new Date();
const cached = await MarketCap.find({
    symbol: { $in: symbols },
    validUntil: { $gt: now },  // ← 关键：只返回未过期的
}).lean();
```

**Mongoose模型检查方法**:
```typescript
// 文件: database/models/market-cap.model.ts:64-66
marketCapSchema.methods.isExpired = function (): boolean {
    return new Date() > this.validUntil;
};
```

## 📊 数据写入策略

### MongoDB L2
```typescript
// 文件: lib/cache/market-cap-cache-manager.ts:174-188
const bulkOps = Array.from(dataMap.entries()).map(([symbol, data]) => ({
    updateOne: {
        filter: { symbol },
        update: {
            $set: {
                marketCap: data.marketCap,
                price: data.price,
                source: data.source,
                lastUpdated: now,
                validUntil: tomorrow,  // ← 设置为明天
            },
        },
        upsert: true,  // ← 不存在则插入
    },
}));
```

**有效期计算**:
```typescript
const now = new Date();
const tomorrow = new Date(now);
tomorrow.setDate(tomorrow.getDate() + 1);
tomorrow.setHours(0, 0, 0, 0);  // 明天00:00:00
```

### Redis L1
```typescript
// 文件: lib/cache/market-cap-cache-manager.ts:122-125
const pipeline = redis.pipeline();
dataMap.forEach((data, symbol) => {
    const key = REDIS_KEY_PREFIX + symbol;  // marketcap:AAPL
    pipeline.setex(key, CACHE_TTL, JSON.stringify(data));  // TTL=3600秒
});
```

## 🔄 完整数据流

### 缓存读取流程
```
1️⃣ 接收请求: getMarketCapCache(symbols)
   ↓
2️⃣ Redis L1: 批量读取
   ├─ 命中 → 返回数据
   └─ 未命中 → 收集缺失列表
   ↓
3️⃣ MongoDB L2: 批量读取
   ├─ 命中且未过期 → 返回数据 + 写入Redis
   └─ 未命中或过期 → 收集缺失列表
   ↓
4️⃣ API获取 (仅缺失部分)
   ├─ Yahoo Finance (100支/批)
   ├─ Finnhub回退 (50支/批)
   └─ 价格估算 (最终回退)
   ↓
5️⃣ 写入双层缓存
   ├─ Redis L1: TTL=1小时
   └─ MongoDB L2: validUntil=24小时
   ↓
6️⃣ 返回: Map<symbol, MarketCapData>
```

## 🎯 更新时机矩阵

| 场景 | 是否更新 | 触发机制 | 说明 |
|------|---------|----------|------|
| **定时任务** | ✅ | UTC 21:30 | 每日收盘后批量更新 |
| **添加股票** | ✅ | 即时异步 | 新股票预缓存 |
| **读取过期** | ✅ | 按需 | 自动补全缺失数据 |
| **读取未过期** | ❌ | - | 直接返回缓存 |
| **同一股票** | ❌ | 幂等 | 多次请求返回相同数据 |

## 📈 性能优化

### 批量处理
- **定时任务**: 100支/批
- **API调用**: Yahoo(100支) + Finnhub(50支)
- **数据库**: BulkWrite批量写入
- **Redis**: Pipeline批量操作

### 缓存命中率优化
- **L1缓存**: 1小时TTL，热门股票高命中
- **L2缓存**: 24小时有效期，几乎100%命中
- **自动预热**: 添加股票时立即缓存

### 容错机制
- **多数据源**: Yahoo → Finnhub → Fallback
- **失败容忍**: 单个股票失败不影响整体
- **降级策略**: API失败时使用历史数据

## 🔧 监控与调试

### 查看缓存状态
```bash
npm run cache:check
```

### 生成可视化报告
```bash
npm run cache:visualize
```

### 日志位置
```
[Cache L1] Hit rate: X% (N/M)
[Cache L2] Hit rate: X% (N/M)
[MongoDB] ✅ Cached N symbols
[Redis] ✅ Cached N symbols
[Watchlist] ✅ Pre-cached market cap for XXX
```

## 总结

市值缓存更新机制采用**多层次、多触发**策略：

- 🎯 **定时更新**: 每日收盘后批量刷新
- ⚡ **即时预缓存**: 添加股票时立即缓存
- 🔄 **被动更新**: 读取时自动补全
- 💾 **双层保障**: Redis(快) + MongoDB(持久)
- ⏰ **智能过期**: 24小时有效期

确保了**性能、及时性、可靠性**的完美平衡！🎉
